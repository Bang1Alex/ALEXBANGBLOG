

## 1、HTTP的基本概念
http：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端<font style="background-color:#FBDE28;">请求应答的标准(TCP)</font>,用于从WWW服务器传输超文本到本地浏览器的<font style="background-color:#FBDE28;">超文本传输协议</font>

### 1.1、HTTP工作原理
HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应



### 1.2、HTTP请求/响应的步骤
1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接收请求并返回HTTP响应
4. 释放TCP连接
5. 客户端解析HTML内容

> 记忆口诀：连接发送加响应，释放解析整过程
>

### 1.3、HTTP请求的物种方法
+ GET---获取资源
+ POST---传输资源
+ PUT---更新资源
+ DELETE--删除资源
+ HEAD--获取报文首部

### 1.4、GET和POST的区别
1. 浏览器的回退表现不同：GET在浏览器回退时是无害的，而POST会在次提交请求
2. 浏览器对请求地址的处理不同：GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置
3. 浏览器对响应的处理不同：GET请求在URL请求参数会被完整的保留在浏览器器的历史记录里面，而POST参会不会保留
4. 参数大小不同：GET请求在URL中传送的参数是有长度限制的，而POST没有限制
5. 安全性不同：GET参数通过URL传递，会暴露，不安全。POST放在请求体中，相对来说更安全一点
6. 针对数据操作的类型不同：GET对数据进行查询，POST主要对数据进行增删改。GET是只读，POST是写。

## 2、HTTPS的基本概念
https：是以安全为目标的HTTP通道，即HTTP下加入SSL层进行加密。

https协议的作用：是建立一个信息安全通道，来确保数据的传输，确保网站的真实性

### 2.1http和https的区别
+ http是超文本传输协议。信息是明文传输，https则是具安全性的ssl加密的传输协议
+ HTTPS协议需要ca证书，费用较高
+ 使用不同的连接方式，端口也不同，http的端口是80，https的端口是443
+ http的连接很简单，是无状态的。

> 记忆口诀：明文传输超文本，安全等级各不同，CA证书费用高，无状态连接端难同。
>

### 2.2HTTPS的工作原理
<!-- 这是一张图片，ocr 内容为：0MS SYN 30MS SYN-ACK 60MS ACK/CLIENT HELLO 90MS _SERVER HELLO/证书 120MS 客户端秘钥(协商) 140MS 完成 160MS 数据传输 -->
![](https://cdn.nlark.com/yuque/0/2022/png/34137445/1670936740103-8ff770ba-fac4-4c32-a6d9-2021ab82f0ba.png)

1. 客户端和web服务器开始协商SSL连接的安全等级，也就是加密等级。
2. 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并从传送给网站，
3. web服务器通过自己的私钥解密出会话密钥
4. web服务器通过会话密钥加密与客户端之间的通信

> 协商安全等级，建立会话密钥，传送给客户端
>

### 2.3 HTTP的状态码
+ <font style="color:black;">1xx：指示信息类，表示请求已接受，继续处理</font>
+ <font style="color:black;">2xx：指示成功类，表示请求已成功接受</font>
+ <font style="color:black;">3xx：指示重定向，表示要完成请求必须进行更近一步的操作</font>
+ <font style="color:black;">4xx：指示客户端错误，请求有语法错误或请求无法实现</font>
+ <font style="color:black;">5xx：指示服务器错误，服务器未能实现合法的请求</font>

<font style="color:black;">详细的状态码：</font>

+ <font style="color:black;">200 OK：客户端请求成功</font>
+ <font style="color:black;">301 Moved Permanently：所请求的页面已经永久重定向至新的URL</font>
+ <font style="color:black;">302 Found：所请求的页面已经临时重定向至新的URL</font>
+ <font style="color:black;">304 Not Modified 未修改。</font>
+ <font style="color:black;">403 Forbidden：对请求页面的访问被禁止</font>
+ <font style="color:black;">404 Not Found：请求资源不存在</font>
+ <font style="color:black;">500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</font>
+ <font style="color:black;">503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</font>

### <font style="color:black;">2.4</font><font style="color:rgb(0, 0, 0);">强制缓存 && 协商缓存</font>


## 3、TCP/IP网络模型
<font style="color:rgb(0, 0, 0);">TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</font>

+ <font style="color:black;">链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</font>
+ <font style="color:black;">网络层：负责路由以及把分组报文发送给目标网络或主机。</font>
+ <font style="color:black;">传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</font>
+ <font style="color:black;">应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</font>

<!-- 这是一张图片，ocr 内容为：功能 OSI七层模型 TCP/IP协议族 TCP/IP概念层模型 应用层 文件传输,电子邮件,文件服务,虚拟终端 TFTP,HTTP,SNMP,FTP,SNTP,DNS,TELNET 没有协议 表示层 数据格式化,代码转换,数据加密 应用层 会话层 解除或建立与别的接点的联系 没有协议 传输层 提供端对端的接口 传输层 TCP,UDP 网络层 IP,ICMP,RIP,OSPF,BGP,IGHP 网络层 为数据包选择路由 数据链路层 传输有地址的帧以及错误检测功能 SLIP,CSLIP,PPP,ARP,RARP,MTU 链路层 IS02110,项BE6021180该术社区 物理层 以二进制数据形式在物理媒体上传输数据 -->
![](https://cdn.nlark.com/yuque/0/2022/png/34137445/1670936714908-5470add8-d5ef-4985-97b7-eaee7982c4c7.png)



### 3.1TCP三次握手和四次挥手
#### 三次握手：
首先服务端是处于监听状态，客户端向服务端发送连接请求报文，SYN=1，ACK=0，选择一个初始的需要seq=x，然后服务器端收到客户端的请求，如果同意连接，则向客户端发送连接确认报文，SYN=1，ACK=1，确认号。ack=x+1,同时也选择一个初始序号ack=y，客户端收到服务器端的连接确认报文后，为了防止失效报文重复出现连接中，还要向服务器端发出确认报文，确认号seq=x+1，ack = y+1，最后服务器端确认以后建立连接

#### 四次挥手
意思是说双方都可以同时向对方发送或接收数据。当客户端要关闭连接时，会发送请求告知服务器我要关闭连接了。这时服务器会回一个确认数据，这时客户端到服务器的连接关闭。但是服务器到客户端的连接并没断开仍然可继续传输数据，等到服务器发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。客户端发送ACK确认关闭连接 此时双方的连接都关闭了即挥手成功

————————————————

1. <font style="color:rgb(239, 112, 96);">客户端进程发出连接释放报文</font><font style="color:black;">，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</font>

<font style="color:rgb(0, 0, 0);">2）</font><font style="color:rgb(239, 112, 96);">服务器收到连接释放报文，发出确认报文</font><font style="color:rgb(0, 0, 0);">，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</font>

<font style="color:rgb(0, 0, 0);">3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</font>

<font style="color:rgb(0, 0, 0);">4）</font><font style="color:rgb(239, 112, 96);">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</font><font style="color:rgb(0, 0, 0);">，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</font>

<font style="color:rgb(0, 0, 0);">5）</font><font style="color:rgb(239, 112, 96);">客户端收到服务器的连接释放报文后，必须发出确认</font><font style="color:rgb(0, 0, 0);">，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</font>

<font style="color:rgb(0, 0, 0);">6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结</font><font style="color:rgb(0, 0, 0);">束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</font>





### 3.2TCP和UDP的区别
1. TCP是面向连接的，而UDP是面向无连接的。
2. TCP仅支持<font style="color:#ECAA04;">单播传输，</font><font style="color:#000000;">UDP提供单播，多播，广播的功能</font>
3. <font style="color:#000000;">TCP的三次握手保证了连接的可靠性，UDP是无连接的，不可靠的一种数据传输协议，首先不可靠体现在无连接，通信不需要建立连接，对接收到数据也不发送确认信号，发送端不知数据是否正确接收</font>
4. <font style="color:#000000;">UDP的头部比TCP小，数据纯属效率更高，实时性更好</font>

<font style="color:#000000;"></font>

## <font style="color:rgb(0, 0, 0);">4、HTTP 请求跨域问题</font>
1. <font style="color:black;">跨域的原理</font>**<font style="color:black;">跨域</font>**<font style="color:black;">，是指浏览器不能执行其他网站的脚本。它是由浏览器的</font><font style="color:rgb(239, 112, 96);">同源策略</font><font style="color:black;">造成的。\</font>**<font style="color:black;">同源策略</font>**<font style="color:black;">,是浏览器对 JavaScript 实施的安全限制，只要</font><font style="color:rgb(239, 112, 96);">协议、域名、端口</font><font style="color:black;">有任何一个不同，都被当作是不同的域。\</font>**<font style="color:black;">跨域原理</font>**<font style="color:black;">，即是通过各种方式，</font><font style="color:rgb(239, 112, 96);">避开浏览器的安全限制</font><font style="color:black;">。</font>
2. <font style="color:black;">解决方案最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</font>

**<font style="color:rgb(0, 0, 0);">JSONP</font>**<font style="color:rgb(0, 0, 0);">：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</font>  
 <font style="color:rgb(0, 0, 0);">步骤：</font>

1. <font style="color:black;">去创建一个script标签</font>
2. <font style="color:black;">script的src属性设置接口地址</font>
3. <font style="color:black;">接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</font>
4. <font style="color:black;">通过定义函数名去接受返回的数据</font>

```javascript
//动态创建 script
var script = document.createElement('script');

// 设置回调函数
function getData(data) {
    console.log(data);
}

//设置 script 的 src 属性，并设置请求地址
script.src = 'http://localhost:3000/?callback=getData';

// 让 script 生效
document.body.appendChild(script);
```

+ **<font style="color:black;">JSONP 的缺点</font>**<font style="color:black;">:\</font><font style="color:black;">JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</font>
+ **<font style="color:black;">document.domain</font>**<font style="color:black;"> 基础域名相同 子域名不同</font>
+ **<font style="color:black;">window.name</font>**<font style="color:black;"> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</font>
+ **<font style="color:black;">CORS</font>**<font style="color:black;"> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</font>
+ **<font style="color:black;">proxy代理</font>**<font style="color:black;"> 目前常用方式</font>
+ **<font style="color:black;">window.postMessage()</font>**<font style="color:black;"> 利用h5新特性 window.postMessage()</font>
+ **<font style="color:black;">Websocket</font>**

**<font style="color:black;"></font>**

## <font style="color:black;">Cookie、SessionStorage、localStorage的区别</font>
+ 相同点：

存在客户端

+ 不同点：
    1. <font style="color:rgb(0, 0, 0);">cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</font>
    2. <font style="color:rgb(0, 0, 0);">cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</font>
    3. <font style="color:rgb(0, 0, 0);">cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</font>

## <font style="color:rgb(0, 0, 0);"></font>
#### 


